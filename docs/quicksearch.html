<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_gibbon-processor.js.html":{"id":"lib_gibbon-processor.js.html","title":"Source: lib/gibbon-processor.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Source: lib/gibbon-processor.js 'use strict'; /** * @classdesc * Just a class to carry byte position and bit position around * * @param {Number} byteNo - unsigned integer value (0..n) * @param {Number} bitPos - unsigned integer value (0..n) * @class */ function BitByte(byteNo, bitPos) { this.byteNo = byteNo; this.bitPos = bitPos; } /** * This is the Gibbon Processor which does all the bit masking, nothing special ;) * @namespace */ const GibbonProcessor = {}; /** * Transforms a position (1..n) to byte index and inner bit position * * @example * * getByteNoAndBitPos(1); // returns { byteNo: 0, bitPos: 0} * * getByteNoAndBitPos(256); // returns { byteNo: 31, bitPos: 7} * * @memberOf GibbonProcessor * @param {Number} position - Unsigned integer value (1..n) * @returns {BitByte} - A new a BitByte instance * @throws {Error} when position is &lt;= 0 */ GibbonProcessor.getByteNoAndBitPos = function (position) { if (position &lt;= 0) { throw new Error('Illegal position'); } const index = position - 1; return new BitByte(Math.trunc(index / 8), index % 8); }; /** * Check if bit is set true on index * * @example * * isTrue(13, 2); // returns true * * // 0000 1101 data * // * // 0000 0011 data (after data &gt;&gt;= index) * // 0000 0001 * // ---------- AND * // 0000 0001 === 0000 0001 (true) * // * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {boolean} */ GibbonProcessor.isTrue = function (data, index) { /* eslint-disable */ data &gt;&gt;= index; return (data &amp; 0x1) === 0x1; /* eslint-enable */ }; /** * Check if bit is set false on index * * @example * * isFalse(13, 2); // returns false * * // 0000 1101 data * // * // 0000 0011 data (after data &gt;&gt;= index) * // 0000 0001 * // ---------- AND * // 0000 0001 === 0000 0000 (false) * // * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {boolean} */ GibbonProcessor.isFalse = function (data, index) { /* eslint-disable */ data &gt;&gt;= index; return (data &amp; 0x1) === 0x0; /* eslint-enable */ }; /** * Set bit true on data from index * * @example * * setBit(0, 1); // returns 1 * * // 0000 0000 data * // 0000 0001 mask * // ---------------- OR * // 0000 0001 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.setBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data | mask; /* eslint-enable */ }; /** * Set bit false on data from index * * @example * * clearBit(1, 0); // returns 0(dec) * * // 0000 0001 mask * // * // 0000 0001 data * // 1111 1110 ~mask * // ---------------- AND * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.clearBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data &amp; ~mask; /* eslint-enable */ }; /** * Change bit according to given value on data from index * * @example * * changeBit(1, 0, false); // returns 0(dec) * * // 0000 0001 data * // 1111 1110 mask ~ * // ---------------- AND * // 0000 0000 x1 * // * // 0000 0000 state * // 0000 0001 mask * // ---------------- AND * // 0000 0000 x2 * // * // 0000 0000 (x1) * // 0000 0000 (x2) * // ---------------- OR * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @param {*} value - truthy | falsy * @returns {Number} */ GibbonProcessor.changeBit = function (data, index, value) { /* eslint-disable */ let mask = 1 &lt;&lt; index; // value relies on true = 1 and false = 0 let state = value ? 0x1 : 0x0; return (data &amp; ~mask) | (-state &amp; mask); /* eslint-enable */ }; /** * Toggle (inverse) bit value on data from index * * @example * * toggleBit(1, 0); // Returns 0(dec) * * // 0000 0001 mask * // 0000 0001 data * // --------------- XOR * // 0000 0000 result * * @memberOf GibbonProcessor * @param {Number} data - Unsigned integer value * @param {Number} index - Unsigned integer value (0..7) * @returns {Number} */ GibbonProcessor.toggleBit = function (data, index) { /* eslint-disable */ let mask = 1 &lt;&lt; index; return data ^ mask; /* eslint-enable */ }; module.exports.GibbonProcessor = GibbonProcessor; module.exports.BitByte = BitByte; Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"test_adapters_lokijs-gibbon-adapter.js.html":{"id":"test_adapters_lokijs-gibbon-adapter.js.html","title":"Source: test/adapters/lokijs-gibbon-adapter.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Source: test/adapters/lokijs-gibbon-adapter.js 'use strict'; const util = require('util'); const _ = require('lodash'); const Loki = require('lokijs'); const GibbonAdapter = require('./../../lib/adapters/gibbon-adapter'); const Gibbon = require('../../lib/gibbon'); /** * * @type {{USER: string, GROUP: string, PERMISSION: string}} */ const COLLECTION = { USER: 'user', GROUP: 'group', PERMISSION: 'permission' }; /** * @classdesc * Representing an adapter class for LokiJS&lt;br&gt; * &lt;b&gt;(NOTE: This an example adapter, which is used to build and test Gibbons, and can be overridden. One is encouraged to write adapters themselves)&lt;/b&gt; * * @class * @augments GibbonAdapter */ function LokiJSGibbonAdapter() { GibbonAdapter.call(this); Object.defineProperty(this, 'dbCollection', { writable: true, enumerable: true, configurable: false, value: {} }); Object.defineProperty(this, 'db', { writable: true, enumerable: true, configurable: false, value: null }); } util.inherits(LokiJSGibbonAdapter, GibbonAdapter); /** * This gets a collection when not set, it will be created * @param {string} collectionName - document collection to be initialized * @private */ LokiJSGibbonAdapter.prototype._initializeCollection = function (collectionName) { this.dbCollection[collectionName] = this.db.getCollection(collectionName); if (!this.dbCollection[collectionName]) { this.dbCollection[collectionName] = this.db.addCollection(collectionName, { unique: ['name'] }); } }; /** * Callback when upsert is done (insert new or update is exists). * @callback LokiJSGibbonAdapter~_upsertByCollection * @param {Error} [error=null] - Error is omitted * @param {object} [dataFound] - One instance of a fetched record * */ /** * Generic Upsert method for user, group and permission collections * * @param {string} collection - Dynamic pointer to a collection * @param {object} criteria - In this adapter name is our unique reference for all collections * @param {object} data - Object to update or insert * @param {LokiJSGibbonAdapter~_upsertByCollection} callback * @private */ LokiJSGibbonAdapter.prototype._upsertByCollection = function (collection, criteria, data, callback) { try { let dataFound = this.dbCollection[collection].findOne({name: criteria.name}); if (!dataFound) { dataFound = this.dbCollection[collection].insert(data); } else { dataFound = Object.assign(dataFound, data); this.dbCollection[collection].update(dataFound); } callback(null, dataFound); } catch (error) { return callback(error); } }; /** * Callback when document fetching is done * @callback LokiJSGibbonAdapter~findByNameCallback * @param {Error} [error=null] - Error is thrown by LokiJS * @param {object} [userObject] - Instance of a fetched record * */ /** * Generic private method to dynamically query the collection and fetch data * @param {string} name - Collection name to query * @param {object} criteria - Criteria for finding data * @param {LokiJSGibbonAdapter~findByNameCallback} callback * @private */ LokiJSGibbonAdapter.prototype._findByCollection = function (name, criteria, callback) { try { const found = this.dbCollection[name].findOne(criteria); callback(null, found); } catch (error) { callback(error); } }; /** * Callback when initializing is done. * @callback LokiJSGibbonAdapter~initializeCallback */ /** * Initialize persistence storage itself and it's collections * * @override * @param {LokiJSGibbonAdapter~initializeCallback} callback - Callback when done */ LokiJSGibbonAdapter.prototype.initialize = function (callback) { const self = this; this.db = new Loki('lokijs.db', { autosave: false, autoload: true, verbose: true, autoloadCallback: loadHandler, }); function loadHandler() { // Initialize all collections self._initializeCollection(COLLECTION.USER); self._initializeCollection(COLLECTION.GROUP); self._initializeCollection(COLLECTION.PERMISSION); callback(); } }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findUser * @see {@link _findByCollection} */ /** * Tries to fetch a user * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findUser} callback */ LokiJSGibbonAdapter.prototype.findUser = function (criteria, callback) { this._findByCollection(COLLECTION.USER, criteria, callback); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findUsersByPermission * @param {Error} [error=null] - Error when Loki throws an error * @param {object} [users] - Collection of found users */ /** * Tries to fetch users by a permission * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findUsersByPermission} callback */ LokiJSGibbonAdapter.prototype.findUsersByPermission = function (criteria, callback) { const self = this; self.findPermission(criteria, (error, permission) =&gt; { if (error) { return callback(error); } if (!permission) { return callback(new Error('Permission not found')); } try { const permissionPosition = permission['$loki']; const groups = self.dbCollection[COLLECTION.GROUP].where((group) =&gt; { const gibbon = Gibbon.fromString(group.permissions); return gibbon.isPosition(permissionPosition); }); const groupPositions = groups.map((group) =&gt; { return group['$loki']; }); const users = self.dbCollection[COLLECTION.USER].where((user) =&gt; { const gibbon = Gibbon.fromString(user.groups); return gibbon.hasAnyFromPositions(groupPositions); }); callback(null, users); } catch (error) { callback(error); } }); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findUsersByGroup * @param {Error} [error=null] - Error when Loki throws an error * @param {object} [users] - Collection of found users */ /** * Tries to fetch users by a group * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findUsersByGroup} callback */ LokiJSGibbonAdapter.prototype.findUsersByGroup = function (criteria, callback) { const self = this; self.findGroup(criteria, (error, group) =&gt; { if (error) { return callback(error); } if (!group) { return callback(new Error('Group not found')); } try { const groupPosition = group['$loki']; const users = self.dbCollection[COLLECTION.USER].where((user) =&gt; { const gibbon = Gibbon.fromString(user.groups); return gibbon.isPosition(groupPosition); }); callback(null, users); } catch (error) { callback(error); } }); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findGroupsByPermission * @param {Error} [error=null] - Error when Loki throws an error * @param {object} [users] - Collection of found groups */ /** * Tries to fetch groups by a permission * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findGroupsByPermission} callback */ LokiJSGibbonAdapter.prototype.findGroupsByPermission = function (criteria, callback) { const self = this; self.findPermission(criteria, (error, permission) =&gt; { if (error) { return callback(error); } if (!permission) { return callback(new Error('Permission not found')); } try { const permissionPosition = permission['$loki']; const groups = self.dbCollection[COLLECTION.GROUP].where((group) =&gt; { const gibbon = Gibbon.fromString(group.permissions); return gibbon.isPosition(permissionPosition); }); callback(null, groups); } catch (error) { callback(error); } }); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findGroup * @see {@link _findByCollection} */ /** * Tries to fetch a group * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findGroup} callback */ LokiJSGibbonAdapter.prototype.findGroup = function (criteria, callback) { this._findByCollection(COLLECTION.GROUP, criteria, callback); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findPermission * @see {@link _findByCollection} */ /** * Tries to find a permission * * @override * @param {object} criteria - LokiJS criteria * @param {LokiJSGibbonAdapter~findPermission} callback */ LokiJSGibbonAdapter.prototype.findPermission = function (criteria, callback) { this._findByCollection(COLLECTION.PERMISSION, criteria, callback); }; /** * Callback when add is done. * @callback LokiJSGibbonAdapter~addUser * @param {Error} [error] - Error thrown by LokiJS * @param {object} [user] - Added user */ /** * Add a user object to the user collection * * @override * @param {object} user - The user object * @param {LokiJSGibbonAdapter~addUser} callback */ LokiJSGibbonAdapter.prototype.addUser = function (user, callback) { try { this.dbCollection[COLLECTION.USER].insert(user); callback(null, user); } catch (error) { callback(error); } }; /** * Callback when add is done. * @callback LokiJSGibbonAdapter~addGroup * @param {Error} [error] - Error thrown by LokiJS * @param {object} [user] - Added group */ /** * Add a group object to the group collection * * @override * @param {object} group - The group object * @param {LokiJSGibbonAdapter~addGroup} callback */ LokiJSGibbonAdapter.prototype.addGroup = function (group, callback) { try { this.dbCollection[COLLECTION.GROUP].insert(group); callback(null, group); } catch (error) { callback(error); } }; /** * Callback when add is done. * @callback LokiJSGibbonAdapter~addGroups * @param {Error} [error] - Error thrown by LokiJS * @param {Array} [groups] - Added groups */ /** * Add a groups from array to the group collection * * @override * @param {Array} groups - The group object * @param {LokiJSGibbonAdapter~addGroups} callback */ LokiJSGibbonAdapter.prototype.addGroups = function (groups, callback) { try { this.dbCollection[COLLECTION.GROUP].insert(groups); callback(null, groups); } catch (error) { callback(error); } }; /** * Callback when add is done. * @callback LokiJSGibbonAdapter~addPermission * @param {Error} [error] - Error thrown by LokiJS * @param {object} [permission] - Added permissions */ /** * Add a permission object to the permission collection * * @override * @param {object} permission - The permission object * @param {LokiJSGibbonAdapter~addPermission} callback */ LokiJSGibbonAdapter.prototype.addPermission = function (permission, callback) { try { this.dbCollection[COLLECTION.PERMISSION].insert(permission); callback(null, permission); } catch (error) { callback(error); } }; /** * Callback when add is done. * @callback LokiJSGibbonAdapter~addPermissions * @param {Error} [error] - This could contain an error emitted by LokiJS * @param {Array} [permissions] - Inserted permissions */ /** * Add a permission from array to the permission collection * * @override * @param {Array} permissions - The permission object * @param {LokiJSGibbonAdapter~addPermissions} callback */ LokiJSGibbonAdapter.prototype.addPermissions = function (permissions, callback) { try { this.dbCollection[COLLECTION.PERMISSION].insert(permissions); callback(null, permissions); } catch (error) { callback(error); } }; /** * Callback when removal is done. * @callback LokiJSGibbonAdapter~removeUser * @param {Error} [error] - This could contain an error thrown by LokiJS */ /** * Remove a user from the user collection * * @override * @param {object} user * @param {LokiJSGibbonAdapter~removeUser} callback */ LokiJSGibbonAdapter.prototype.removeUser = function (user, callback) { try { this.dbCollection[COLLECTION.USER].findAndRemove({name: user.name}); callback(); } catch (error) { callback(error); } }; /** * Callback when removal is done. * @callback LokiJSGibbonAdapter~removeGroup * @param {Error} [error] - This could contain an error thrown by LokiJS */ /** * Tries to fetch the given group, if found it does a cascaded removal of the groups stored in all users * Then removes the mentioned group from the group collection itself * * @override * @param {object} group * @param {LokiJSGibbonAdapter~removeGroup} callback */ LokiJSGibbonAdapter.prototype.removeGroup = function (group, callback) { try { const groupFound = this.dbCollection[COLLECTION.GROUP].findOne({name: group.name}); const groupFoundPosition = groupFound['$loki']; if (groupFoundPosition !== undefined) { // Remove all associated permissions stored at users this.dbCollection[COLLECTION.USER].findAndUpdate({}, (user) =&gt; { if (typeof user.groups === 'string') { const gibbon = Gibbon.fromString(user.groups); gibbon.clearPosition(groupFoundPosition); user.groups = gibbon.toString(); } }); } // Last step, to remove the record itself. this.dbCollection[COLLECTION.GROUP].findAndRemove({'$loki': groupFoundPosition}); callback(); } catch (error) { callback(error); } }; /** * Callback when removal is done. * @callback LokiJSGibbonAdapter~removePermission * @param {Error} [error] - This could contain an error thrown by LokiJS */ /** * Tries to fetch the given permission, if found it does a cascaded removal of the permissions stored in all groups * Then removes the mentioned permission from the permission collection itself * * @override * @param {object} permission * @param {LokiJSGibbonAdapter~removePermission} callback */ LokiJSGibbonAdapter.prototype.removePermission = function (permission, callback) { try { const permissionFound = this.dbCollection[COLLECTION.PERMISSION].findOne({name: permission.name}); const permissionFoundPosition = permissionFound['$loki']; if (permissionFoundPosition !== undefined) { // Remove all associated permissions stored at groups this.dbCollection[COLLECTION.GROUP].findAndUpdate({}, (group) =&gt; { if (typeof group.permissions === 'string') { const gibbon = Gibbon.fromString(group.permissions); gibbon.clearPosition(permissionFoundPosition); group.permissions = gibbon.toString(); } }); } // Last step, to remove the record itself. this.dbCollection[COLLECTION.PERMISSION].findAndRemove({'$loki': permissionFoundPosition}); callback(); } catch (error) { callback(error); } }; /** * Callback when update is done. * @callback LokiJSGibbonAdapter~upsertUser * @see {@link _upsertByCollection} */ /** * Insert or update a user (if not exists) * * @override * @param {object} criteria - Where to find in case of update * @param {object} user - The user to update or insert * @param {LokiJSGibbonAdapter~upsertUser} callback */ LokiJSGibbonAdapter.prototype.upsertUser = function (criteria, user, callback) { this._upsertByCollection(COLLECTION.USER, criteria, user, callback); }; /** * Callback when update is done. * @callback LokiJSGibbonAdapter~upsertGroup * @see {@link _upsertByCollection} */ /** * Insert or update group (if not exists) * * @override * @param {object} criteria - LokiJS criteria * @param {object} group - Group object * @param {LokiJSGibbonAdapter~upsertGroup} callback */ LokiJSGibbonAdapter.prototype.upsertGroup = function (criteria, group, callback) { this._upsertByCollection(COLLECTION.GROUP, criteria, group, callback); }; /** * Callback when update is done. * @callback LokiJSGibbonAdapter~upsertPermission * @see {@link _upsertByCollection} */ /** * Insert or update a permission (if not exists) * * @override * @param {object} criteria - LokiJS criteria * @param {object} permission - Permission object * @param {LokiJSGibbonAdapter~upsertPermission} callback */ LokiJSGibbonAdapter.prototype.upsertPermission = function (criteria, permission, callback) { this._upsertByCollection(COLLECTION.PERMISSION, criteria, permission, callback); }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findGroupsByUser * @param {Error} [error] - If user not found or an error thrown by LokiJS * @param {Array} [groups] - Fetched groups from one given user */ /** * Tries to fetch a collection of groups * * @override * @param {object} user - user object * @param {LokiJSGibbonAdapter~findGroupsByUser} callback */ LokiJSGibbonAdapter.prototype.findGroupsByUser = function (user, callback) { try { // Fetch user from lokijs const userFound = this.dbCollection[COLLECTION.USER].findOne({name: user.name}); if (!userFound) { return callback(new Error('user not found')); } // construct a new Gibbon instance from encoded groups const gibbon = Gibbon.fromString(userFound.groups); // Fetch lokijs groups from group collection const positions = gibbon.getPositionsArray(); const criteria = {'$loki': {'$in': positions}}; const groups = this.dbCollection[COLLECTION.GROUP].find(criteria); callback(null, groups); } catch (error) { callback(error); } }; /** * Callback when fetching is done. * @callback LokiJSGibbonAdapter~findPermissionsByUser * @param {Error} [error] - If user not found or an error thrown by LokiJS * @param {Array} [permissions] - Fetched permissions from one given user */ /** * Given a user, it tries to fetch it's permissions * * @override * @param {object} user - Instance of a user object * @param {LokiJSGibbonAdapter~findPermissionsByUser} callback */ LokiJSGibbonAdapter.prototype.findPermissionsByUser = function (user, callback) { const self = this; let permissions = []; this.findGroupsByUser(user, (err, groups) =&gt; { if (err) { return callback(err); } let i = 0; for (i; i &lt; groups.length; i++) { const group = groups[i]; const permissionsFromGroup = group.permissions; const gibbon = Gibbon.fromString(permissionsFromGroup); const permissionBitPositions = gibbon.getPositionsArray(); permissions = permissions.concat(permissionBitPositions); permissions = Array.from(new Set(permissions)); } permissions = permissions.sort((a, b) =&gt; { return a - b; }); const criteria = {'$loki': {'$in': permissions}}; const permissionsFound = self.dbCollection[COLLECTION.PERMISSION].find(criteria); return callback(null, permissionsFound); }); }; /** * Callback when validating is done. * @callback LokiJSGibbonAdapter~validateUserWithAllPermissions * @param {Error} [error] - If user not found or an error thrown by LokiJS * @param {boolean} valid - When valid or not */ /** * Validate a user against all given permissions &lt;br&gt; * When one of the given permissions is missing for the given user,&lt;br&gt; * given user is not valid. * * @override * @param {object} user - User to validate * @param {Array&lt;Number&gt;} permissions - Array with unsigned integers with permissions (positions starting at 1) * @param {LokiJSGibbonAdapter~validateUserWithAllPermissions} callback */ LokiJSGibbonAdapter.prototype.validateUserWithAllPermissions = function (user, permissions, callback) { let valid = false; this.findPermissionsByUser(user, (error, permissionsFound) =&gt; { if (error) { return callback(error, valid); } if (!(Array.isArray(permissions)) || permissions.length &lt;= 0) { return callback(null, valid); } const permissionsAttachedToUser = permissionsFound.map((permission) =&gt; { return permission['$loki']; }); const missingPermissions = _.difference(permissions, permissionsAttachedToUser); valid = !(Array.isArray(missingPermissions) &amp;&amp; missingPermissions.length &gt; 0); callback(null, valid); }); }; /** * Callback when validating is done. * @callback LokiJSGibbonAdapter~validateUserWithAnyPermissions * @param {Error} [error] - If user not found or an error thrown by LokiJS * @param {boolean} valid - When valid or not */ /** * Validate a user against any given permissions &lt;br&gt; * When one of the given permissions is found for the given user,&lt;br&gt; * the outcome is valid. * @override * @param {object} user - User to validate * @param {Array&lt;Number&gt;} permissions - Array with unsigned integers with permissions (positions starting at 1) * @param {LokiJSGibbonAdapter~validateUserWithAnyPermissions} callback */ LokiJSGibbonAdapter.prototype.validateUserWithAnyPermissions = function (user, permissions, callback) { let valid = false; this.findPermissionsByUser(user, (error, permissionsFound) =&gt; { if (error) { return callback(error, valid); } if (!(Array.isArray(permissions)) || permissions.length &lt;= 0) { return callback(null, valid); } const permissionsAttachedToUser = permissionsFound.map((permission) =&gt; { return permission['$loki']; }); const overlappingPermissions = _.intersection(permissions, permissionsAttachedToUser); valid = (Array.isArray(overlappingPermissions) &amp;&amp; overlappingPermissions.length &gt; 0); callback(null, valid); }); }; module.exports = LokiJSGibbonAdapter; Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"lib_gibbon.js.html":{"id":"lib_gibbon.js.html","title":"Source: lib/gibbon.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Source: lib/gibbon.js 'use strict'; const GibbonProcessor = require('./gibbon-processor').GibbonProcessor; /** * A Gibbon * @class * @param {ArrayBuffer} arrayBuffer - allocate this Gibbon with some working memory * @throws {TypeError} if arrayBuffer is not an instance of ArrayBuffer */ function Gibbon(arrayBuffer) { if (!(arrayBuffer instanceof ArrayBuffer)) { throw new TypeError('argument not an instance of ArrayBuffer'); } this.arrayBuffer = arrayBuffer; this.dataView = new DataView(this.arrayBuffer); } /** * Compare two gibbon instances on data contents * * @param {Gibbon} gibbon - instance of &lt;b&gt;a&lt;/b&gt; Gibbon * @returns {boolean} if instance (or contents) are the same * @throws {TypeError} if gibbon is not an instance of Gibbon */ Gibbon.prototype.compare = function (gibbon) { let same = false; if (!(gibbon instanceof Gibbon)) { throw new TypeError('gibbon is not an instance of Gibbon'); } const arrayBuffer = gibbon.arrayBuffer; const thisArrayBuffer = this.arrayBuffer; if (thisArrayBuffer === arrayBuffer) { same = true; } else { const thisDataView = this.dataView; const dataView = gibbon.dataView; const byteLength = Math.max(thisArrayBuffer.byteLength, arrayBuffer.byteLength); let result = true; for (let i = 0; i &lt; byteLength &amp;&amp; result; i++) { const value1 = (i &lt; thisDataView.byteLength) ? thisDataView.getUint8(i) : 0x0; const value2 = (i &lt; dataView.byteLength) ? dataView.getUint8(i) : 0x0; if (value1 !== value2) { result = false; } } same = result; } return same; }; /** * This method analyzes every bit value in this gibbon and creates the corresponding &lt;br&gt; * position array where bits are logical true. * * @example * * * // Initialize a Gibbon (2 bytes) * const gibbon = Gibbon.create(2); * * // Pre set some bit positions * gibbon.setPosition(1) * .setPosition(2) * .setPosition(3) * .setPosition(4) * .setPosition(5) * .setPosition(6) * .setPosition(7) * .setPosition(8) * .setPosition(10); * * gibbon.getPositionsArray(); // returns: [1, 2, 3, 4, 5, 6, 7, 8, 10] * * * @returns {Array} Which contains bit positions from this gibbon, which are logical set to true */ Gibbon.prototype.getPositionsArray = function () { const dataView = this.dataView; const byteLength = this.arrayBuffer.byteLength; const positions = []; for (let byteNo = 0; byteNo &lt; byteLength; byteNo++) { const value = dataView.getUint8(byteNo); for (let bitPos = 0; bitPos &lt; 8; bitPos++) { const posValue = GibbonProcessor.isTrue(value, bitPos); if (posValue) { positions.push(byteNo * 8 + bitPos + 1); } } } return positions; }; /** * Set bit: true according to integer position in the Gibbon &lt;br&gt; * &lt;i&gt;Note: Starting from 1&lt;/i&gt; * @throws {Error} Position can't exceed data view bounds. * @param {Number} position - unsigned integer value * @returns {Gibbon} - For chaining purposes */ Gibbon.prototype.setPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); const dataViewBounds = this.dataView.byteLength; if (bitBytePosition.byteNo &lt; dataViewBounds) { let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.setBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); } else { // Because we can't exceed the amount of allocated bytes, // Please ensure position ends within the allocated memory throw new Error('Illegal position'); } return this; }; /** * Set bit: false according to integer position * Note: Starting from 1 * @param {Number} position - unsigned integer value * @returns {Gibbon} */ Gibbon.prototype.clearPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.clearBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Toggle bit value true =&gt; false, false =&gt; true * @example * * const gibbon = Gibbon.create(2); * gibbon.changePosition(1, true); * * gibbon.isPosition(1); // true * * @param {Number} position - unsigned integer value * @returns {Gibbon} */ Gibbon.prototype.togglePosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.toggleBit(byte, bitBytePosition.bitPos); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Set value for a bit on position * * @example * * const gibbon = Gibbon.create(2); * gibbon.changePosition(1, true); * * gibbon.isPosition(1); // returns true * * * @param {Number} position - unsigned integer value * @param {boolean} [on] - Optional set true or false (default : false) * @returns {Gibbon} - Return itself for chaining purposes */ Gibbon.prototype.changePosition = function (position, on = false) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.changeBit(byte, bitBytePosition.bitPos, on); this.dataView.setUint8(bitBytePosition.byteNo, byte); return this; }; /** * Checks if a value is true or false on a specific position * * * @example * * const gibbon = Gibbon.create(2); * gibbon.setPosition(1); * * gibbon.isPosition(1); // returns true * * @param {Number} position - unsigned integer value * @returns {boolean} if membership is set */ Gibbon.prototype.isPosition = function (position) { const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(position); let byte = this.dataView.getUint8(bitBytePosition.byteNo); const result = GibbonProcessor.isTrue(byte, bitBytePosition.bitPos); return result; }; /** * Compares all given positions * - A positive position means this position should be set logical '1' * - A negative position means this position should be set logical '0' * * When one wants to check on bit positions outside the memory bounds (dataViewBounds), &lt;br&gt; * method wil return early with `false`. * * * @example * * // Initialize a gibbon with 2 bytes * const gibbon = Gibbon.create(2); * // Set 2 bit positions to logical '1' * gibbon.setPosition(1).setPosition(2); * * gibbon.hasAllFromPositions([1, 2]); // true * * @example * * // Set 2 bit positions to logical '1' then the first bit position back to '0' * const gibbon = Gibbon.create(2); * gibbon.setPosition(1).setPosition(2),togglePosition(1); * * gibbon.hasAllFromPositions([-1, 2]); // true * * @param {Array&lt;Number&gt;} positionArray - containing signed integer values (representing bit positions) * @return {boolean} true when all positions correspondent to the given indexes * @throws {TypeError} if positionArray is not an instance of array * */ Gibbon.prototype.hasAllFromPositions = function (positionArray = []) { const self = this; const dataViewBounds = self.dataView.byteLength; if (!(Array.isArray(positionArray))) { throw new TypeError('positionArray not an instance of Array'); } // Shallow copy let positions = positionArray.slice(0); // Remove duplicate values: positions = positions.filter(function (value, index, self) { return self.indexOf(value) === index; }); // Check bits on position if they are truthy (positive position) or falsy (negative position) let hasAllFromPositions = true; // Exit early when one of the positions is not logic true. for (let i = 0; i &lt; positions.length &amp;&amp; hasAllFromPositions; i++) { const position = positions[i]; const positionAbs = Math.abs(position); const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(positionAbs); // Check if position is not out of bound of the data view: if (bitBytePosition.byteNo &lt; dataViewBounds) { const byte = self.dataView.getUint8(bitBytePosition.byteNo); if (position &gt;= 0) { hasAllFromPositions = GibbonProcessor.isTrue(byte, bitBytePosition.bitPos); } else { hasAllFromPositions = GibbonProcessor.isFalse(byte, bitBytePosition.bitPos); } } else { // Position is outside the bounds of the DataView, skipping the rest... hasAllFromPositions = false; } } return hasAllFromPositions; }; /** * Compares the given positions * - A positive position means this position should be set logical '1' * - A negative position means this position should be set logical '0' * * When any of the positions conforms to logical '1' (true), we return `true` early. * * When one wants to check on bit positions outside the memory bounds (dataViewBounds), &lt;br&gt; * method wil return early with `false`. * * * @example * * // Initialize a gibbon with 2 bytes * const gibbon = Gibbon.create(2); * // Set 3 bit positions to logical '1' * gibbon.setPosition(1).setPosition(2).setPosition(10); * * gibbon.hasAnyFromPositions([1, 9]); // true * * @example * * // Set 2 bit positions to logical '1' then the first bit position back to '0' * const gibbon = Gibbon.create(2); * gibbon.setPosition(1).setPosition(2),togglePosition(1); * * gibbon.hasAllFromPositions([-1, 100]); // true * * @param {Array&lt;Number&gt;} positionArray - containing signed integer values (representing bit positions) * @return {boolean} true when one of these positions correspond * @throws {TypeError} if positionArray is not an instance of array */ Gibbon.prototype.hasAnyFromPositions = function (positionArray = []) { let hasAny = false; const self = this; const dataViewBounds = self.dataView.byteLength; if (!(Array.isArray(positionArray))) { throw new TypeError('positionArray not an instance of Array'); } // Shallow copy and remove duplicate values: let positions = positionArray.slice(0).filter(function (value, index, self) { return self.indexOf(value) === index; }); // Check bits on position if they are truthy (positive position) or falsy (negative position) // Exit early when one of the positions is not logic true. for (let i = 0; i &lt; positions.length &amp;&amp; !hasAny; i++) { const position = positions[i]; const positionAbs = Math.abs(position); const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(positionAbs); // Check if position is not out of bound of the data view: if (bitBytePosition.byteNo &lt; dataViewBounds) { const byte = self.dataView.getUint8(bitBytePosition.byteNo); if (position &gt;= 0) { hasAny = GibbonProcessor.isTrue(byte, bitBytePosition.bitPos); } else { hasAny = GibbonProcessor.isFalse(byte, bitBytePosition.bitPos); } } } return hasAny; }; /** * Able to manipulate bits according to an array of signed integers * * @example * * // Set 2 bit positions to logical '1' * const gibbon = Gibbon.create(2); * gibbon.setAllFromPositions([1, 2]); * gibbon.hasAllFromPositions([1, 2]); // returns true * * @example * * // Set 1 bit positions to logical '1' and the second to '0' * const gibbon = Gibbon.create(2); * gibbon.setAllFromPositions([1, -2]); * gibbon.hasAllFromPositions([1]); // returns true * * @param {Array&lt;Number&gt;} positionArray - Array with integer values starting from 1. * @returns {Gibbon} - For chaining purposes * @throws {TypeError} if positionArray is not an instance of array */ Gibbon.prototype.setAllFromPositions = function (positionArray = []) { const self = this; const dataViewBounds = self.dataView.byteLength; if (!(Array.isArray(positionArray))) { throw new TypeError('positionArray not an instance of Array'); } // Shallow copy let positions = positionArray.slice(); // Remove duplicate values: positions = positions.filter(function (value, index, self) { return self.indexOf(value) === index; }); for (let i = 0; i &lt; positions.length; i++) { const position = positions[i]; const positionAbs = Math.abs(position); const bitBytePosition = GibbonProcessor.getByteNoAndBitPos(positionAbs); // Check if position is not out of bound of the data view: if (bitBytePosition.byteNo &lt; dataViewBounds) { let byte = self.dataView.getUint8(bitBytePosition.byteNo); byte = GibbonProcessor.changeBit(byte, bitBytePosition.bitPos, (position &gt;= 0)); self.dataView.setUint8(bitBytePosition.byteNo, byte); } } return self; }; /** * Convert the whole ArrayBuffer to a string&lt;br&gt; * (Hint: Could be used to store a gibbon in persistent storage as a encoded string) * * @returns {string} - Encoded string * @override */ Gibbon.prototype.toString = function () { return String.fromCharCode.apply(null, new Uint16Array(this.arrayBuffer)); }; /** * Class method to create a new Gibbon from a string&lt;br&gt; * (Hint: Could be used to retrieve from persistent storage) * * @param {string} str - Representing a new Gibbon instance * @returns {Gibbon} - new instance of a Gibbon * @throws {TypeError} if given argument is not an instance of string */ Gibbon.fromString = function (str = '') { if (typeof str !== 'string') { throw new TypeError('argument not a string'); } const arrayBuffer = new ArrayBuffer(str.length * 2); // 2 bytes for each char const typedArray = new Uint16Array(arrayBuffer); for (let i = 0, strLen = str.length; i &lt; strLen; i++) { typedArray[i] = str.charCodeAt(i); } return new Gibbon(arrayBuffer); }; /** * Creates a new empty Gibbon from a given byte size * @param {Number} byteSize - Allocate this Gibbon with a unsigned integer value (size in bytes) * @returns {Gibbon} - new instance of a Gibbon */ Gibbon.create = function (byteSize) { const arrayBuffer = new ArrayBuffer(byteSize); return new Gibbon(arrayBuffer); }; module.exports = Gibbon; Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"lib_adapters_gibbon-adapter.js.html":{"id":"lib_adapters_gibbon-adapter.js.html","title":"Source: lib/adapters/gibbon-adapter.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Source: lib/adapters/gibbon-adapter.js 'use strict'; const INHERITANCE_ERROR = 'Abstract method, override please.'; /** * @classdesc * * This class should be inherited and acts as contract (Interface) * * @extends EventEmitter * @class * @abstract */ function GibbonAdapter() { } /** * Initialize adapter * * @abstract */ GibbonAdapter.prototype.initialize = function () { throw new Error(INHERITANCE_ERROR); }; GibbonAdapter.prototype.addUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add user group * * @abstract */ GibbonAdapter.prototype.addGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add array of user groups * * @abstract */ GibbonAdapter.prototype.addGroups = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add group permission * @abstract */ GibbonAdapter.prototype.addPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Add array of permissions * @abstract */ GibbonAdapter.prototype.addPermissions = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a user * @abstract */ GibbonAdapter.prototype.removeUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a group * @abstract */ GibbonAdapter.prototype.removeGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Remove a permission * @abstract */ GibbonAdapter.prototype.removePermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert user (if not exists) * @abstract */ GibbonAdapter.prototype.upsertUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert group (if not exists) * @abstract */ GibbonAdapter.prototype.upsertGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Update or insert permission (if not exists) * @abstract */ GibbonAdapter.prototype.upsertPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user groups * @abstract */ GibbonAdapter.prototype.findGroupsByUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user permissions * @abstract */ GibbonAdapter.prototype.findPermissionsByUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find user * @abstract */ GibbonAdapter.prototype.findUser = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find users with permission * @abstract */ GibbonAdapter.prototype.findUsersByPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find users with group * @abstract */ GibbonAdapter.prototype.findUsersByGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find groups with permission */ GibbonAdapter.prototype.findGroupsByPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find group * @abstract */ GibbonAdapter.prototype.findGroup = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find array of groups * @abstract */ GibbonAdapter.prototype.findGroups = function () { throw new Error(INHERITANCE_ERROR); }; /** * Find permission * @abstract */ GibbonAdapter.prototype.findPermission = function () { throw new Error(INHERITANCE_ERROR); }; /** * Validate a user against e.g. given permissions &lt;br&gt; * All permissions given, need to correspond with the permissions owned by this user. * * @abstract */ GibbonAdapter.prototype.validateUserWithAllPermissions = function () { throw new Error(INHERITANCE_ERROR); }; /** * Validate a user against e.g. given permissions &lt;br&gt; * When one of the given permissions are found at this user, user is valid. * @abstract */ GibbonAdapter.prototype.validateUserWithAnyPermissions = function () { throw new Error(INHERITANCE_ERROR); }; module.exports = GibbonAdapter; Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"lib_gibbons.js.html":{"id":"lib_gibbons.js.html","title":"Source: lib/gibbons.js","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Source: lib/gibbons.js 'use strict'; const GibbonAdapter = require('./adapters/gibbon-adapter'); /** * @class * * This is the Gibbons class&lt;br&gt; * It's the entry point for group- and permission handling * * @param {GibbonAdapter} gibbonAdapter - An instance of GibbonAdapter is required. * @throws {TypeError} When given argument is not an instance of GibbonAdapter * */ function Gibbons(gibbonAdapter) { if (!(gibbonAdapter instanceof GibbonAdapter)) { throw new TypeError('adapter processor not of expected type'); } const adapter = gibbonAdapter; Object.defineProperty(this, 'adapter', { get: function () { return adapter; } }); } /** * Initializes Gibbons&lt;br&gt; * (it initializes the given adapter) * * @param {function} callback */ Gibbons.prototype.initialize = function (callback) { this.adapter.initialize(callback); }; /** * Finds a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - User to find * @param {function} callback */ Gibbons.prototype.findUser = function (criteria, callback) { this.adapter.findUser(criteria, callback); }; /** * Finds a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Group to find * @param {function} callback */ Gibbons.prototype.findGroup = function (criteria, callback) { this.adapter.findGroup(criteria, callback); }; /** * Finds a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Permission to find * @param {function} callback */ Gibbons.prototype.findPermission = function (criteria, callback) { this.adapter.findPermission(criteria, callback); }; /** * Finds users attached to groups which contains a certain permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - permission to find users by * @param {function} callback */ Gibbons.prototype.findUsersByPermission = function (criteria, callback) { this.adapter.findUsersByPermission(criteria, callback); }; /** * Finds users attached to a certain group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - group to find users by * @param {function} callback */ Gibbons.prototype.findUsersByGroup = function (criteria, callback) { this.adapter.findUsersByGroup(criteria, callback); }; /** * Finds groups attached to given permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - permission to find groups by * @param {function} callback */ Gibbons.prototype.findGroupsByPermission = function (criteria, callback) { this.adapter.findGroupsByPermission(criteria, callback); }; /** * Adds a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User to add * @param {function} callback */ Gibbons.prototype.addUser = function (user, callback) { this.adapter.addUser(user, callback); }; /** * Add a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} group - Group to add * @param {function} callback */ Gibbons.prototype.addGroup = function (group, callback) { this.adapter.addGroup(group, callback); }; /** * Adds an array of groups&lt;br&gt; * (Is delegated to a given adapter) * * @param {Array&lt;object&gt;} groups - Collection of groups to add * @param {function} callback */ Gibbons.prototype.addGroups = function (groups, callback) { this.adapter.addGroups(groups, callback); }; /** * Add a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} permission - Permission to add * @param {function} callback */ Gibbons.prototype.addPermission = function (permission, callback) { this.adapter.addPermission(permission, callback); }; /** * Adds an array of permissions&lt;br&gt; * (Is delegated to a given adapter) * * @param {Array&lt;object&gt;} permissions - Collection of permissions to add * @param {function} callback */ Gibbons.prototype.addPermissions = function (permissions, callback) { this.adapter.addPermissions(permissions, callback); }; /** * Removes a user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria for removal of a certain user * @param {function} callback */ Gibbons.prototype.removeUser = function (user, callback) { this.adapter.removeUser(user, callback); }; /** * Removes a group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} group - Group criteria for removal of a certain group * @param {function} callback */ Gibbons.prototype.removeGroup = function (group, callback) { this.adapter.removeGroup(group, callback); }; /** * Removes a permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} permission - Permission criteria for removal of a certain permission * @param {function} callback */ Gibbons.prototype.removePermission = function (permission, callback) { this.adapter.removePermission(permission, callback); }; /** * Updates an existing user, and if not found inserts the user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - User criteria to update when found * @param {object} user - Data to merge with existing user, or to insert * @param {function} callback */ Gibbons.prototype.upsertUser = function (criteria, user, callback) { this.adapter.upsertUser(criteria, user, callback); }; /** * Updates an existing group, and if not found inserts the group&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Group criteria to update when found * @param {object} group - Data to merge with existing group, or to insert * @param {function} callback */ Gibbons.prototype.upsertGroup = function (criteria, group, callback) { this.adapter.upsertGroup(criteria, group, callback); }; /** * Updates an existing permission, and if not found inserts the permission&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} criteria - Permission criteria to update when found * @param {object} permission - Data to merge with existing permission, or to insert * @param {function} callback */ Gibbons.prototype.upsertPermission = function (criteria, permission, callback) { this.adapter.upsertPermission(criteria, permission, callback); }; /** * Finds a group collection attached to this certain user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria to find the corresponding groups * @param {function} callback */ Gibbons.prototype.findGroupsByUser = function (user, callback) { this.adapter.findGroupsByUser(user, callback); }; /** * Finds a permission collection attached to this certain user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User criteria to find the corresponding permissions * @param {function} callback */ Gibbons.prototype.findPermissionsByUser = function (user, callback) { this.adapter.findPermissionsByUser(user, callback); }; /** * Validates given user against given array of permission positions. * &lt;b&gt;All&lt;/b&gt; given permissions need to be found at this given user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User as criteria to validate * @param {Array&lt;Number&gt;} permissions * @param {function} callback */ Gibbons.prototype.validateUserWithAllPermissions = function (user, permissions, callback) { this.adapter.validateUserWithAllPermissions(user, permissions, callback); }; /** * Validates given user against given array of permission positions. * &lt;b&gt;If any&lt;/b&gt; given permission is found attached to this given user&lt;br&gt; * (Is delegated to a given adapter) * * @param {object} user - User to validate permissions against * @param {Array&lt;Number&gt;} permissions - Permission collection of integers * @param {function} callback */ Gibbons.prototype.validateUserWithAnyPermissions = function (user, permissions, callback) { this.adapter.validateUserWithAnyPermissions(user, permissions, callback); }; module.exports = Gibbons; Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Global Members &lt;constant&gt; COLLECTION :Object Type: Object Source: test/adapters/lokijs-gibbon-adapter.js, line 12 Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Classes Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Namespaces Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Tutorials Classes BitByte Gibbon GibbonAdapter Gibbons LokiJSGibbonAdapter Namespaces GibbonProcessor Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Gibbons&quot;Leaping from branch to branch gibbons decide which one to take in a split second&quot; Gibbons is a Node.js module which helps in managing user groups and user permissions with bitwise efficiency. In applying ArrayBuffers and bitwise operations it tries to use minimal resources. API Documentation and tutorialSee: Gibbons Docs How do I get set up?npm install gibbons DetailsPrerequisites to contribute Clone this repository, and check out the develop branch Ensure Node Version Manager is installed and operational nvm install npm install -g gulp LintingFor this project ESLint is applied. Execute: gulp lint Currently the linter conforms to defaults from: eslint-plugin-node and some minor tweaks (see: .eslint.js). Unit testsEvery path should be covered and can be checked after the unit test is executed, according to a coverage report. Execute: gulp test In the end, a brief version of the coverage report is shown. For the more extensive one, see: test/coverage/lcov-report/index.html. API DocumentationA Gulp plugin: gulp-jsdoc3 is applied to generate the API documentation. It's expected to write extensive comments in the code itself when contributing. Every time code is updated, we need to ensure the documentation is in sync with the code. Execute: gulp docs The result is generated at: docs/index.html Contribution guidelines When adding new features / code, creating corresponding unit tests are mandatory Code review will be done by means of pull requests to the develop branch, preferably with the following pull request template: h1. I ensured: * [ ] I've updated the unit tests and covered enough parts of the code (`gulp lint` and `gulp test`) * [ ] I've updated the API documentation within the code and generated a fresh export (`gulp docs`)ChangesSee: Changelog Meta data Maintainer: Ivo Cazemier Bitbucket or Github API documentation and tutorial (License: MIT, See the LICENSE file) Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"BitByte.html":{"id":"BitByte.html","title":"Class: BitByte","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Class: BitByte BitByte Just a class to carry byte position and bit position around new BitByte(byteNo, bitPos) Parameters: Name Type Description byteNo Number unsigned integer value (0..n) bitPos Number unsigned integer value (0..n) Source: lib/gibbon-processor.js, line 11 Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"Gibbon.html":{"id":"Gibbon.html","title":"Class: Gibbon","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Class: Gibbon Gibbon new Gibbon(arrayBuffer) A Gibbon Parameters: Name Type Description arrayBuffer ArrayBuffer allocate this Gibbon with some working memory Source: lib/gibbon.js, line 11 Throws: if arrayBuffer is not an instance of ArrayBuffer Type TypeError Methods &lt;static&gt; create(byteSize) Creates a new empty Gibbon from a given byte size Parameters: Name Type Description byteSize Number Allocate this Gibbon with a unsigned integer value (size in bytes) Source: lib/gibbon.js, line 421 Returns: new instance of a Gibbon Type Gibbon &lt;static&gt; fromString(str) Class method to create a new Gibbon from a string (Hint: Could be used to retrieve from persistent storage) Parameters: Name Type Description str string Representing a new Gibbon instance Source: lib/gibbon.js, line 403 Throws: if given argument is not an instance of string Type TypeError Returns: new instance of a Gibbon Type Gibbon changePosition(position [, on]) Set value for a bit on position Parameters: Name Type Argument Description position Number unsigned integer value on boolean &lt;optional&gt; Optional set true or false (default : false) Source: lib/gibbon.js, line 167 Returns: Return itself for chaining purposes Type Gibbon Example const gibbon = Gibbon.create(2); gibbon.changePosition(1, true); gibbon.isPosition(1); // returns true clearPosition(position) Set bit: false according to integer position Note: Starting from 1 Parameters: Name Type Description position Number unsigned integer value Source: lib/gibbon.js, line 124 Returns: Type Gibbon compare(gibbon) Compare two gibbon instances on data contents Parameters: Name Type Description gibbon Gibbon instance of a Gibbon Source: lib/gibbon.js, line 27 Throws: if gibbon is not an instance of Gibbon Type TypeError Returns: if instance (or contents) are the same Type boolean getPositionsArray() This method analyzes every bit value in this gibbon and creates the corresponding position array where bits are logical true. Source: lib/gibbon.js, line 80 Returns: Which contains bit positions from this gibbon, which are logical set to true Type Array Example // Initialize a Gibbon (2 bytes) const gibbon = Gibbon.create(2); // Pre set some bit positions gibbon.setPosition(1) .setPosition(2) .setPosition(3) .setPosition(4) .setPosition(5) .setPosition(6) .setPosition(7) .setPosition(8) .setPosition(10); gibbon.getPositionsArray(); // returns: [1, 2, 3, 4, 5, 6, 7, 8, 10] hasAllFromPositions(positionArray) Compares all given positions A positive position means this position should be set logical '1' A negative position means this position should be set logical '0' When one wants to check on bit positions outside the memory bounds (dataViewBounds), method wil return early with false. Parameters: Name Type Description positionArray Array.&lt;Number&gt; containing signed integer values (representing bit positions) Source: lib/gibbon.js, line 227 Throws: if positionArray is not an instance of array Type TypeError Returns: true when all positions correspondent to the given indexes Type boolean Examples // Initialize a gibbon with 2 bytes const gibbon = Gibbon.create(2); // Set 2 bit positions to logical '1' gibbon.setPosition(1).setPosition(2); gibbon.hasAllFromPositions([1, 2]); // true // Set 2 bit positions to logical '1' then the first bit position back to '0' const gibbon = Gibbon.create(2); gibbon.setPosition(1).setPosition(2),togglePosition(1); gibbon.hasAllFromPositions([-1, 2]); // true hasAnyFromPositions(positionArray) Compares the given positions A positive position means this position should be set logical '1' A negative position means this position should be set logical '0' When any of the positions conforms to logical '1' (true), we return true early. When one wants to check on bit positions outside the memory bounds (dataViewBounds), method wil return early with false. Parameters: Name Type Description positionArray Array.&lt;Number&gt; containing signed integer values (representing bit positions) Source: lib/gibbon.js, line 300 Throws: if positionArray is not an instance of array Type TypeError Returns: true when one of these positions correspond Type boolean Examples // Initialize a gibbon with 2 bytes const gibbon = Gibbon.create(2); // Set 3 bit positions to logical '1' gibbon.setPosition(1).setPosition(2).setPosition(10); gibbon.hasAnyFromPositions([1, 9]); // true // Set 2 bit positions to logical '1' then the first bit position back to '0' const gibbon = Gibbon.create(2); gibbon.setPosition(1).setPosition(2),togglePosition(1); gibbon.hasAllFromPositions([-1, 100]); // true isPosition(position) Checks if a value is true or false on a specific position Parameters: Name Type Description position Number unsigned integer value Source: lib/gibbon.js, line 189 Returns: if membership is set Type boolean Example const gibbon = Gibbon.create(2); gibbon.setPosition(1); gibbon.isPosition(1); // returns true setAllFromPositions(positionArray) Able to manipulate bits according to an array of signed integers Parameters: Name Type Description positionArray Array.&lt;Number&gt; Array with integer values starting from 1. Source: lib/gibbon.js, line 354 Throws: if positionArray is not an instance of array Type TypeError Returns: For chaining purposes Type Gibbon Examples // Set 2 bit positions to logical '1' const gibbon = Gibbon.create(2); gibbon.setAllFromPositions([1, 2]); gibbon.hasAllFromPositions([1, 2]); // returns true // Set 1 bit positions to logical '1' and the second to '0' const gibbon = Gibbon.create(2); gibbon.setAllFromPositions([1, -2]); gibbon.hasAllFromPositions([1]); // returns true setPosition(position) Set bit: true according to integer position in the Gibbon Note: Starting from 1 Parameters: Name Type Description position Number unsigned integer value Source: lib/gibbon.js, line 103 Throws: Position can't exceed data view bounds. Type Error Returns: For chaining purposes Type Gibbon togglePosition(position) Toggle bit value true =&gt; false, false =&gt; true Parameters: Name Type Description position Number unsigned integer value Source: lib/gibbon.js, line 144 Returns: Type Gibbon Example const gibbon = Gibbon.create(2); gibbon.changePosition(1, true); gibbon.isPosition(1); // true toString() Convert the whole ArrayBuffer to a string (Hint: Could be used to store a gibbon in persistent storage as a encoded string) Source: lib/gibbon.js, line 391 Returns: Encoded string Type string Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"GibbonAdapter.html":{"id":"GibbonAdapter.html","title":"Class: GibbonAdapter","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Class: GibbonAdapter GibbonAdapter This class should be inherited and acts as contract (Interface) &lt;abstract&gt; new GibbonAdapter() Source: lib/adapters/gibbon-adapter.js, line 13 Extends EventEmitter Methods &lt;abstract&gt; addGroup() Add user group Source: lib/adapters/gibbon-adapter.js, line 36 &lt;abstract&gt; addGroups() Add array of user groups Source: lib/adapters/gibbon-adapter.js, line 45 &lt;abstract&gt; addPermission() Add group permission Source: lib/adapters/gibbon-adapter.js, line 53 &lt;abstract&gt; addPermissions() Add array of permissions Source: lib/adapters/gibbon-adapter.js, line 61 &lt;abstract&gt; findGroup() Find group Source: lib/adapters/gibbon-adapter.js, line 167 &lt;abstract&gt; findGroups() Find array of groups Source: lib/adapters/gibbon-adapter.js, line 175 findGroupsByPermission() Find groups with permission Source: lib/adapters/gibbon-adapter.js, line 159 &lt;abstract&gt; findGroupsByUser() Find user groups Source: lib/adapters/gibbon-adapter.js, line 118 &lt;abstract&gt; findPermission() Find permission Source: lib/adapters/gibbon-adapter.js, line 183 &lt;abstract&gt; findPermissionsByUser() Find user permissions Source: lib/adapters/gibbon-adapter.js, line 126 &lt;abstract&gt; findUser() Find user Source: lib/adapters/gibbon-adapter.js, line 135 &lt;abstract&gt; findUsersByGroup() Find users with group Source: lib/adapters/gibbon-adapter.js, line 152 &lt;abstract&gt; findUsersByPermission() Find users with permission Source: lib/adapters/gibbon-adapter.js, line 144 &lt;abstract&gt; initialize() Initialize adapter Source: lib/adapters/gibbon-adapter.js, line 22 &lt;abstract&gt; removeGroup() Remove a group Source: lib/adapters/gibbon-adapter.js, line 77 &lt;abstract&gt; removePermission() Remove a permission Source: lib/adapters/gibbon-adapter.js, line 85 &lt;abstract&gt; removeUser() Remove a user Source: lib/adapters/gibbon-adapter.js, line 69 &lt;abstract&gt; upsertGroup() Update or insert group (if not exists) Source: lib/adapters/gibbon-adapter.js, line 102 &lt;abstract&gt; upsertPermission() Update or insert permission (if not exists) Source: lib/adapters/gibbon-adapter.js, line 110 &lt;abstract&gt; upsertUser() Update or insert user (if not exists) Source: lib/adapters/gibbon-adapter.js, line 94 &lt;abstract&gt; validateUserWithAllPermissions() Validate a user against e.g. given permissions All permissions given, need to correspond with the permissions owned by this user. Source: lib/adapters/gibbon-adapter.js, line 194 &lt;abstract&gt; validateUserWithAnyPermissions() Validate a user against e.g. given permissions When one of the given permissions are found at this user, user is valid. Source: lib/adapters/gibbon-adapter.js, line 203 Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"GibbonProcessor.html":{"id":"GibbonProcessor.html","title":"Namespace: GibbonProcessor","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Namespace: GibbonProcessor GibbonProcessor This is the Gibbon Processor which does all the bit masking, nothing special ;) Source: lib/gibbon-processor.js, line 20 Methods &lt;static&gt; changeBit(data, index, value) Change bit according to given value on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) value * truthy | falsy Source: lib/gibbon-processor.js, line 177 Returns: Type Number Example changeBit(1, 0, false); // returns 0(dec) // 0000 0001 data // 1111 1110 mask ~ // ---------------- AND // 0000 0000 x1 // // 0000 0000 state // 0000 0001 mask // ---------------- AND // 0000 0000 x2 // // 0000 0000 (x1) // 0000 0000 (x2) // ---------------- OR // 0000 0000 result &lt;static&gt; clearBit(data, index) Set bit false on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: lib/gibbon-processor.js, line 142 Returns: Type Number Example clearBit(1, 0); // returns 0(dec) // 0000 0001 mask // // 0000 0001 data // 1111 1110 ~mask // ---------------- AND // 0000 0000 result &lt;static&gt; getByteNoAndBitPos(position) Transforms a position (1..n) to byte index and inner bit position Parameters: Name Type Description position Number Unsigned integer value (1..n) Source: lib/gibbon-processor.js, line 37 Throws: when position is &lt;= 0 Type Error Returns: A new a BitByte instance Type BitByte Example getByteNoAndBitPos(1); // returns { byteNo: 0, bitPos: 0} getByteNoAndBitPos(256); // returns { byteNo: 31, bitPos: 7} &lt;static&gt; isFalse(data, index) Check if bit is set false on index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: lib/gibbon-processor.js, line 92 Returns: Type boolean Example isFalse(13, 2); // returns false // 0000 1101 data // // 0000 0011 data (after data &gt;&gt;= index) // 0000 0001 // ---------- AND // 0000 0001 === 0000 0000 (false) // &lt;static&gt; isTrue(data, index) Check if bit is set true on index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: lib/gibbon-processor.js, line 65 Returns: Type boolean Example isTrue(13, 2); // returns true // 0000 1101 data // // 0000 0011 data (after data &gt;&gt;= index) // 0000 0001 // ---------- AND // 0000 0001 === 0000 0001 (true) // &lt;static&gt; setBit(data, index) Set bit true on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: lib/gibbon-processor.js, line 116 Returns: Type Number Example setBit(0, 1); // returns 1 // 0000 0000 data // 0000 0001 mask // ---------------- OR // 0000 0001 result &lt;static&gt; toggleBit(data, index) Toggle (inverse) bit value on data from index Parameters: Name Type Description data Number Unsigned integer value index Number Unsigned integer value (0..7) Source: lib/gibbon-processor.js, line 203 Returns: Type Number Example toggleBit(1, 0); // Returns 0(dec) // 0000 0001 mask // 0000 0001 data // --------------- XOR // 0000 0000 result Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"Gibbons.html":{"id":"Gibbons.html","title":"Class: Gibbons","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Class: Gibbons Gibbons This is the Gibbons class It's the entry point for group- and permission handling new Gibbons(gibbonAdapter) Parameters: Name Type Description gibbonAdapter GibbonAdapter An instance of GibbonAdapter is required. Source: lib/gibbons.js, line 14 Throws: When given argument is not an instance of GibbonAdapter Type TypeError Methods addGroup(group, callback) Add a group (Is delegated to a given adapter) Parameters: Name Type Description group object Group to add callback function Source: lib/gibbons.js, line 124 addGroups(groups, callback) Adds an array of groups (Is delegated to a given adapter) Parameters: Name Type Description groups Array.&lt;object&gt; Collection of groups to add callback function Source: lib/gibbons.js, line 135 addPermission(permission, callback) Add a permission (Is delegated to a given adapter) Parameters: Name Type Description permission object Permission to add callback function Source: lib/gibbons.js, line 146 addPermissions(permissions, callback) Adds an array of permissions (Is delegated to a given adapter) Parameters: Name Type Description permissions Array.&lt;object&gt; Collection of permissions to add callback function Source: lib/gibbons.js, line 157 addUser(user, callback) Adds a user (Is delegated to a given adapter) Parameters: Name Type Description user object User to add callback function Source: lib/gibbons.js, line 113 findGroup(criteria, callback) Finds a group (Is delegated to a given adapter) Parameters: Name Type Description criteria object Group to find callback function Source: lib/gibbons.js, line 56 findGroupsByPermission(criteria, callback) Finds groups attached to given permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object permission to find groups by callback function Source: lib/gibbons.js, line 102 findGroupsByUser(user, callback) Finds a group collection attached to this certain user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria to find the corresponding groups callback function Source: lib/gibbons.js, line 238 findPermission(criteria, callback) Finds a permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object Permission to find callback function Source: lib/gibbons.js, line 68 findPermissionsByUser(user, callback) Finds a permission collection attached to this certain user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria to find the corresponding permissions callback function Source: lib/gibbons.js, line 249 findUser(criteria, callback) Finds a user (Is delegated to a given adapter) Parameters: Name Type Description criteria object User to find callback function Source: lib/gibbons.js, line 45 findUsersByGroup(criteria, callback) Finds users attached to a certain group (Is delegated to a given adapter) Parameters: Name Type Description criteria object group to find users by callback function Source: lib/gibbons.js, line 91 findUsersByPermission(criteria, callback) Finds users attached to groups which contains a certain permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object permission to find users by callback function Source: lib/gibbons.js, line 79 initialize(callback) Initializes Gibbons (it initializes the given adapter) Parameters: Name Type Description callback function Source: lib/gibbons.js, line 34 removeGroup(group, callback) Removes a group (Is delegated to a given adapter) Parameters: Name Type Description group object Group criteria for removal of a certain group callback function Source: lib/gibbons.js, line 179 removePermission(permission, callback) Removes a permission (Is delegated to a given adapter) Parameters: Name Type Description permission object Permission criteria for removal of a certain permission callback function Source: lib/gibbons.js, line 190 removeUser(user, callback) Removes a user (Is delegated to a given adapter) Parameters: Name Type Description user object User criteria for removal of a certain user callback function Source: lib/gibbons.js, line 168 upsertGroup(criteria, group, callback) Updates an existing group, and if not found inserts the group (Is delegated to a given adapter) Parameters: Name Type Description criteria object Group criteria to update when found group object Data to merge with existing group, or to insert callback function Source: lib/gibbons.js, line 215 upsertPermission(criteria, permission, callback) Updates an existing permission, and if not found inserts the permission (Is delegated to a given adapter) Parameters: Name Type Description criteria object Permission criteria to update when found permission object Data to merge with existing permission, or to insert callback function Source: lib/gibbons.js, line 227 upsertUser(criteria, user, callback) Updates an existing user, and if not found inserts the user (Is delegated to a given adapter) Parameters: Name Type Description criteria object User criteria to update when found user object Data to merge with existing user, or to insert callback function Source: lib/gibbons.js, line 202 validateUserWithAllPermissions(user, permissions, callback) Validates given user against given array of permission positions. All given permissions need to be found at this given user (Is delegated to a given adapter) Parameters: Name Type Description user object User as criteria to validate permissions Array.&lt;Number&gt; callback function Source: lib/gibbons.js, line 262 validateUserWithAnyPermissions(user, permissions, callback) Validates given user against given array of permission positions. If any given permission is found attached to this given user (Is delegated to a given adapter) Parameters: Name Type Description user object User to validate permissions against permissions Array.&lt;Number&gt; Permission collection of integers callback function Source: lib/gibbons.js, line 275 Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"LokiJSGibbonAdapter.html":{"id":"LokiJSGibbonAdapter.html","title":"Class: LokiJSGibbonAdapter","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Class: LokiJSGibbonAdapter LokiJSGibbonAdapter Representing an adapter class for LokiJS (NOTE: This an example adapter, which is used to build and test Gibbons, and can be overridden. One is encouraged to write adapters themselves) new LokiJSGibbonAdapter() Source: test/adapters/lokijs-gibbon-adapter.js, line 26 Extends GibbonAdapter Methods &lt;private&gt; _findByCollection(name, criteria, callback) Generic private method to dynamically query the collection and fetch data Parameters: Name Type Description name string Collection name to query criteria object Criteria for finding data callback LokiJSGibbonAdapter~findByNameCallback Source: test/adapters/lokijs-gibbon-adapter.js, line 110 &lt;private&gt; _initializeCollection(collectionName) This gets a collection when not set, it will be created Parameters: Name Type Description collectionName string document collection to be initialized Source: test/adapters/lokijs-gibbon-adapter.js, line 52 &lt;private&gt; _upsertByCollection(collection, criteria, data, callback) Generic Upsert method for user, group and permission collections Parameters: Name Type Description collection string Dynamic pointer to a collection criteria object In this adapter name is our unique reference for all collections data object Object to update or insert callback LokiJSGibbonAdapter~_upsertByCollection Source: test/adapters/lokijs-gibbon-adapter.js, line 80 addGroup() Add user group Inherited From: GibbonAdapter#addGroup Overrides: GibbonAdapter#addGroup Source: lib/adapters/gibbon-adapter.js, line 36 addGroups() Add array of user groups Inherited From: GibbonAdapter#addGroups Overrides: GibbonAdapter#addGroups Source: lib/adapters/gibbon-adapter.js, line 45 addPermission() Add group permission Inherited From: GibbonAdapter#addPermission Overrides: GibbonAdapter#addPermission Source: lib/adapters/gibbon-adapter.js, line 53 addPermissions() Add array of permissions Inherited From: GibbonAdapter#addPermissions Overrides: GibbonAdapter#addPermissions Source: lib/adapters/gibbon-adapter.js, line 61 addUser(user, callback) Add a user object to the user collection Parameters: Name Type Description user object The user object callback LokiJSGibbonAdapter~addUser Source: test/adapters/lokijs-gibbon-adapter.js, line 351 findGroup() Find group Inherited From: GibbonAdapter#findGroup Overrides: GibbonAdapter#findGroup Source: lib/adapters/gibbon-adapter.js, line 167 &lt;abstract&gt; findGroups() Find array of groups Inherited From: GibbonAdapter#findGroups Source: lib/adapters/gibbon-adapter.js, line 175 findGroupsByPermission() Find groups with permission Inherited From: GibbonAdapter#findGroupsByPermission Overrides: GibbonAdapter#findGroupsByPermission Source: lib/adapters/gibbon-adapter.js, line 159 findGroupsByUser() Find user groups Inherited From: GibbonAdapter#findGroupsByUser Overrides: GibbonAdapter#findGroupsByUser Source: lib/adapters/gibbon-adapter.js, line 118 findPermission() Find permission Inherited From: GibbonAdapter#findPermission Overrides: GibbonAdapter#findPermission Source: lib/adapters/gibbon-adapter.js, line 183 findPermissionsByUser() Find user permissions Inherited From: GibbonAdapter#findPermissionsByUser Overrides: GibbonAdapter#findPermissionsByUser Source: lib/adapters/gibbon-adapter.js, line 126 findUser() Find user Inherited From: GibbonAdapter#findUser Overrides: GibbonAdapter#findUser Source: lib/adapters/gibbon-adapter.js, line 135 findUsersByGroup() Find users with group Inherited From: GibbonAdapter#findUsersByGroup Overrides: GibbonAdapter#findUsersByGroup Source: lib/adapters/gibbon-adapter.js, line 152 findUsersByPermission() Find users with permission Inherited From: GibbonAdapter#findUsersByPermission Overrides: GibbonAdapter#findUsersByPermission Source: lib/adapters/gibbon-adapter.js, line 144 initialize() Initialize adapter Inherited From: GibbonAdapter#initialize Overrides: GibbonAdapter#initialize Source: lib/adapters/gibbon-adapter.js, line 22 removeGroup() Remove a group Inherited From: GibbonAdapter#removeGroup Overrides: GibbonAdapter#removeGroup Source: lib/adapters/gibbon-adapter.js, line 77 removePermission() Remove a permission Inherited From: GibbonAdapter#removePermission Overrides: GibbonAdapter#removePermission Source: lib/adapters/gibbon-adapter.js, line 85 removeUser() Remove a user Inherited From: GibbonAdapter#removeUser Overrides: GibbonAdapter#removeUser Source: lib/adapters/gibbon-adapter.js, line 69 upsertGroup() Update or insert group (if not exists) Inherited From: GibbonAdapter#upsertGroup Overrides: GibbonAdapter#upsertGroup Source: lib/adapters/gibbon-adapter.js, line 102 upsertPermission() Update or insert permission (if not exists) Inherited From: GibbonAdapter#upsertPermission Overrides: GibbonAdapter#upsertPermission Source: lib/adapters/gibbon-adapter.js, line 110 upsertUser() Update or insert user (if not exists) Inherited From: GibbonAdapter#upsertUser Overrides: GibbonAdapter#upsertUser Source: lib/adapters/gibbon-adapter.js, line 94 validateUserWithAllPermissions() Validate a user against e.g. given permissions All permissions given, need to correspond with the permissions owned by this user. Inherited From: GibbonAdapter#validateUserWithAllPermissions Overrides: GibbonAdapter#validateUserWithAllPermissions Source: lib/adapters/gibbon-adapter.js, line 194 validateUserWithAnyPermissions() Validate a user against e.g. given permissions When one of the given permissions are found at this user, user is valid. Inherited From: GibbonAdapter#validateUserWithAnyPermissions Overrides: GibbonAdapter#validateUserWithAnyPermissions Source: lib/adapters/gibbon-adapter.js, line 203 Type Definitions _upsertByCollection( [error] [, dataFound]) Callback when upsert is done (insert new or update is exists). Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error is omitted dataFound object &lt;optional&gt; One instance of a fetched record Source: test/adapters/lokijs-gibbon-adapter.js, line 63 addGroup( [error] [, user]) Callback when add is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; Error thrown by LokiJS user object &lt;optional&gt; Added group Source: test/adapters/lokijs-gibbon-adapter.js, line 361 addGroups( [error] [, groups]) Callback when add is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; Error thrown by LokiJS groups Array &lt;optional&gt; Added groups Source: test/adapters/lokijs-gibbon-adapter.js, line 384 addPermission( [error] [, permission]) Callback when add is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; Error thrown by LokiJS permission object &lt;optional&gt; Added permissions Source: test/adapters/lokijs-gibbon-adapter.js, line 407 addPermissions( [error] [, permissions]) Callback when add is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; This could contain an error emitted by LokiJS permissions Array &lt;optional&gt; Inserted permissions Source: test/adapters/lokijs-gibbon-adapter.js, line 430 addUser( [error] [, user]) Callback when add is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; Error thrown by LokiJS user object &lt;optional&gt; Added user Source: test/adapters/lokijs-gibbon-adapter.js, line 337 findByNameCallback( [error] [, userObject]) Callback when document fetching is done Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error is thrown by LokiJS userObject object &lt;optional&gt; Instance of a fetched record Source: test/adapters/lokijs-gibbon-adapter.js, line 95 findGroup() Callback when fetching is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 302 See: _findByCollection findGroupsByPermission( [error] [, users]) Callback when fetching is done. Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error when Loki throws an error users object &lt;optional&gt; Collection of found groups Source: test/adapters/lokijs-gibbon-adapter.js, line 260 findGroupsByUser( [error] [, groups]) Callback when fetching is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; If user not found or an error thrown by LokiJS groups Array &lt;optional&gt; Fetched groups from one given user Source: test/adapters/lokijs-gibbon-adapter.js, line 605 findPermission() Callback when fetching is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 320 See: _findByCollection findPermissionsByUser( [error] [, permissions]) Callback when fetching is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; If user not found or an error thrown by LokiJS permissions Array &lt;optional&gt; Fetched permissions from one given user Source: test/adapters/lokijs-gibbon-adapter.js, line 639 findUser() Callback when fetching is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 151 See: _findByCollection findUsersByGroup( [error] [, users]) Callback when fetching is done. Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error when Loki throws an error users object &lt;optional&gt; Collection of found users Source: test/adapters/lokijs-gibbon-adapter.js, line 218 findUsersByPermission( [error] [, users]) Callback when fetching is done. Parameters: Name Type Argument Default Description error Error &lt;optional&gt; null Error when Loki throws an error users object &lt;optional&gt; Collection of found users Source: test/adapters/lokijs-gibbon-adapter.js, line 168 initializeCallback() Callback when initializing is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 119 removeGroup( [error]) Callback when removal is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; This could contain an error thrown by LokiJS Source: test/adapters/lokijs-gibbon-adapter.js, line 477 removePermission( [error]) Callback when removal is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; This could contain an error thrown by LokiJS Source: test/adapters/lokijs-gibbon-adapter.js, line 514 removeUser( [error]) Callback when removal is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; This could contain an error thrown by LokiJS Source: test/adapters/lokijs-gibbon-adapter.js, line 454 upsertGroup() Callback when update is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 569 See: _upsertByCollection upsertPermission() Callback when update is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 587 See: _upsertByCollection upsertUser() Callback when update is done. Source: test/adapters/lokijs-gibbon-adapter.js, line 551 See: _upsertByCollection validateUserWithAllPermissions( [error], valid) Callback when validating is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; If user not found or an error thrown by LokiJS valid boolean When valid or not Source: test/adapters/lokijs-gibbon-adapter.js, line 683 validateUserWithAnyPermissions( [error], valid) Callback when validating is done. Parameters: Name Type Argument Description error Error &lt;optional&gt; If user not found or an error thrown by LokiJS valid boolean When valid or not Source: test/adapters/lokijs-gibbon-adapter.js, line 719 Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "},"tutorial-Tutorial.html":{"id":"tutorial-Tutorial.html","title":"Tutorial: Tutorial","body":" Gibbons Namespaces GibbonProcessor Classes BitByteGibbonGibbonAdapterGibbonsLokiJSGibbonAdapter Tutorials Tutorial Global COLLECTION Tutorial Coming soon! Ã— Search results Close Gibbons (I. Cazemier) Documentation generated by JSDoc 3.4.3 on 2017-04-10T12:49:50+02:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
